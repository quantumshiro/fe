use ingot::intrinsic::{mload, mstore, sload, sstore}
use ingot::ptr::{LoadableScalar, Ptr, StorableScalar}

// ============================================================================
// Enum helpers for tagged union representation
// ============================================================================
//
// Enum memory layout (tagged union):
// ┌─────────────────┬──────────────────────────────────────┐
// │  Discriminant   │            Variant Data              │
// │   (32 bytes)    │   (size of largest variant payload)  │
// └─────────────────┴──────────────────────────────────────┘
//      offset 0                   offset 32

/// The byte offset where variant data begins (after the 32-byte discriminant).
const ENUM_DATA_OFFSET: u256 = 32

/// Reads the discriminant (variant tag) from an enum's base address.
pub fn get_discriminant<P: Ptr>(addr: u256) -> u256 {
    P::load(addr:addr)
}

/// Stores the discriminant (variant tag) at an enum's base address.
pub fn store_discriminant<P: Ptr>(addr: u256, discriminant: u256) {
    P::store(addr:addr, value:discriminant)
}

/// Reads a scalar field from an enum's variant data region.
/// The field_offset is relative to the start of the variant data (after discriminant).
pub fn get_variant_field<P: Ptr, F: LoadableScalar>(addr: u256, field_offset: u256) -> F {
    let target = addr + ENUM_DATA_OFFSET + field_offset
    F::from_word(word:P::load(addr:target))
}

/// Writes a scalar field into an enum's variant data region.
/// The field_offset is relative to the start of the variant data (after discriminant).
pub fn store_variant_field<P: Ptr, T: StorableScalar>(addr: u256, field_offset: u256, value: T) {
    let target = addr + ENUM_DATA_OFFSET + field_offset
    P::store(addr:target, value:value.to_word())
}
