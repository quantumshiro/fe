use ingot::intrinsic::{mload, mstore, sload, sstore}
use ingot::ptr::{AddressSpace, LoadableScalar, StorableScalar}

// ============================================================================
// Enum helpers for tagged union representation
// ============================================================================
//
// Enum memory layout (tagged union):
// ┌─────────────────┬──────────────────────────────────────┐
// │  Discriminant   │            Variant Data              │
// │   (32 bytes)    │   (size of largest variant payload)  │
// └─────────────────┴──────────────────────────────────────┘
//      offset 0                   offset 32

/// The byte offset where variant data begins (after the 32-byte discriminant).
const ENUM_DATA_OFFSET: u256 = 32

/// Reads the discriminant (variant tag) from an enum's base address.
pub fn get_discriminant(addr: u256, space: AddressSpace) -> u256 {
    match space {
        AddressSpace::Memory => mload(addr)
        AddressSpace::Storage => sload(slot: addr)
    }
}

/// Stores the discriminant (variant tag) at an enum's base address.
pub fn store_discriminant(addr: u256, space: AddressSpace, discriminant: u256) {
    match space {
        AddressSpace::Memory => mstore(addr, discriminant)
        AddressSpace::Storage => sstore(slot: addr, discriminant)
    }
}

/// Reads a scalar field from an enum's variant data region.
/// The field_offset is relative to the start of the variant data (after discriminant).
pub fn get_variant_field<F: LoadableScalar>(addr: u256, space: AddressSpace, field_offset: u256) -> F {
    let target = addr + ENUM_DATA_OFFSET + field_offset
    let word = match space {
        AddressSpace::Memory => mload(target)
        AddressSpace::Storage => sload(slot: target)
    }
    F::from_word(word)
}

/// Writes a scalar field into an enum's variant data region.
/// The field_offset is relative to the start of the variant data (after discriminant).
pub fn store_variant_field<T: StorableScalar>(addr: u256, space: AddressSpace, field_offset: u256, value: T) {
    let target = addr + ENUM_DATA_OFFSET + field_offset
    match space {
        AddressSpace::Memory => mstore(target, value.to_word())
        AddressSpace::Storage => sstore(slot: target, value.to_word())
    }
}
