use ingot::intrinsic::{addr_of, keccak, mstore, sload, sstore}
use ingot::ptr::{LoadableScalar, StorableScalar}

/// Keys that can be written into the mapping preimage for keccak hashing.
pub trait StorageKey {
    /// Writes the key bytes at `ptr` and returns the length written.
    fn write_key(ptr: u256, self) -> u256
}

impl StorageKey for u256 {
    fn write_key(ptr: u256, self) -> u256 {
        mstore(ptr, self)
        32
    }
}

/// A storage-backed mapping from keys `K` to values `V`.
pub struct StorageMap<K, V> {
    /// Private marker field to give the type a non-zero size for layout purposes.
    _m: u256,
}

impl<K: StorageKey, V: LoadableScalar + StorableScalar> StorageMap<K, V> {
    pub fn get(self, key: K) -> V {
        let storage_slot = self.storage_slot(key)
        V::from_word(word: sload(storage_slot))
    }

    pub fn set(self, key: K, value: V) {
        let storage_slot = self.storage_slot(key)
        sstore(storage_slot, value.to_word())
    }

    fn storage_slot(self, key: K) -> u256 {
        // keccak256(key ++ slot) - standard Solidity mapping layout
        let key_len = K::write_key(ptr:0, key)
        mstore(key_len, addr_of(self))
        keccak(0, key_len + 32)
    }
}

impl<A, B> StorageKey for (A, B)
where A: StorageKey,
      B: StorageKey {
    fn write_key(ptr: u256, self) -> u256 {
        let (a, b) = self
        let a_len = A::write_key(ptr, a)
        let b_len = B::write_key(ptr + a_len, b)
        a_len + b_len
    }
}
