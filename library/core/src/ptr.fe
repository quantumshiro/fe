use ingot::intrinsic::{mload, mstore, sload, sstore}
use ingot::num::*

// Masks used to truncate a 256-bit word down to the requested primitive width.
const U8_MASK: u256 = 0xff
const U16_MASK: u256 = 0xffff
const U32_MASK: u256 = 0xffffffff
const U64_MASK: u256 = 0xffffffffffffffff
const U128_MASK: u256 = 0xffffffffffffffffffffffffffffffff
const U256_MASK: u256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

// Sign bits used when performing two's-complement sign extension per width.
const I8_SIGN_BIT: u256 = 0x80
const I16_SIGN_BIT: u256 = 0x8000
const I32_SIGN_BIT: u256 = 0x80000000
const I64_SIGN_BIT: u256 = 0x8000000000000000
const I128_SIGN_BIT: u256 = 0x80000000000000000000000000000000
const I256_SIGN_BIT: u256 = 0x8000000000000000000000000000000000000000000000000000000000000000

/// Memory pointer marker type.
pub struct MemPtr {}

/// Storage pointer marker type.
pub struct StorPtr {}

/// Every scalar that can be reconstructed from a raw 256-bit slot implements this.
pub trait LoadableScalar {
    fn from_word(word: u256) -> Self
}

impl LoadableScalar for u8 {
    fn from_word(word: u256) -> Self {
        __u256_as_u8(word & U8_MASK)
    }
}

impl LoadableScalar for u16 {
    fn from_word(word: u256) -> Self {
        __u256_as_u16(word & U16_MASK)
    }
}

impl LoadableScalar for u32 {
    fn from_word(word: u256) -> Self {
        __u256_as_u32(word & U32_MASK)
    }
}

impl LoadableScalar for u64 {
    fn from_word(word: u256) -> Self {
        __u256_as_u64(word & U64_MASK)
    }
}

impl LoadableScalar for u128 {
    fn from_word(word: u256) -> Self {
        __u256_as_u128(word & U128_MASK)
    }
}

impl LoadableScalar for u256 {
    fn from_word(word: u256) -> Self {
        word
    }
}

impl LoadableScalar for bool {
    fn from_word(word: u256) -> Self {
        word != 0
    }
}

impl LoadableScalar for i8 {
    fn from_word(word: u256) -> Self {
        __u256_as_i8(sign_extend(word, U8_MASK, I8_SIGN_BIT))
    }
}

impl LoadableScalar for i16 {
    fn from_word(word: u256) -> Self {
        __u256_as_i16(sign_extend(word, U16_MASK, I16_SIGN_BIT))
    }
}

impl LoadableScalar for i32 {
    fn from_word(word: u256) -> Self {
        __u256_as_i32(sign_extend(word, U32_MASK, I32_SIGN_BIT))
    }
}

impl LoadableScalar for i64 {
    fn from_word(word: u256) -> Self {
        __u256_as_i64(sign_extend(word, U64_MASK, I64_SIGN_BIT))
    }
}

impl LoadableScalar for i128 {
    fn from_word(word: u256) -> Self {
        __u256_as_i128(sign_extend(word, U128_MASK, I128_SIGN_BIT))
    }
}

impl LoadableScalar for i256 {
    fn from_word(word: u256) -> Self {
        __u256_as_i256(sign_extend(word, U256_MASK, I256_SIGN_BIT))
    }
}

/// Performs two's-complement sign extension within the provided mask/sign bit.
fn sign_extend(word: u256, _ mask: u256, _ sign_bit: u256) -> u256 {
    let value = word & mask
    if value & sign_bit != 0 {
        value | (!mask)
    } else {
        value
    }
}

/// Opposite of `LoadableScalar`: types that can be written back to storage/memory.
pub trait StorableScalar {
    fn to_word(self) -> u256
}

/// Pointer abstraction over raw u256 addresses/slots.
pub trait Ptr {
    fn load(addr: u256) -> u256
    fn store(addr: u256, value: u256)
}

impl Ptr for MemPtr {
    fn load(addr: u256) -> u256 {
        mload(addr)
    }

    fn store(addr: u256, value: u256) {
        mstore(addr, value)
    }
}

impl Ptr for StorPtr {
    fn load(addr: u256) -> u256 {
        sload(slot:addr)
    }

    fn store(addr: u256, value: u256) {
        sstore(slot:addr, value)
    }
}

impl StorableScalar for u8 {
    fn to_word(self) -> u256 {
        __u8_as_u256(self)
    }
}

impl StorableScalar for u16 {
    fn to_word(self) -> u256 {
        __u16_as_u256(self)
    }
}

impl StorableScalar for u32 {
    fn to_word(self) -> u256 {
        __u32_as_u256(self)
    }
}

impl StorableScalar for u64 {
    fn to_word(self) -> u256 {
        __u64_as_u256(self)
    }
}

impl StorableScalar for u128 {
    fn to_word(self) -> u256 {
        __u128_as_u256(self)
    }
}

impl StorableScalar for u256 {
    fn to_word(self) -> u256 {
        self
    }
}

impl StorableScalar for usize {
    fn to_word(self) -> u256 {
        __usize_as_u256(self)
    }
}

impl StorableScalar for bool {
    fn to_word(self) -> u256 {
        if self { 1 } else { 0 }
    }
}

impl StorableScalar for i8 {
    fn to_word(self) -> u256 {
        __i8_as_u256(self)
    }
}

impl StorableScalar for i16 {
    fn to_word(self) -> u256 {
        __i16_as_u256(self)
    }
}

impl StorableScalar for i32 {
    fn to_word(self) -> u256 {
        __i32_as_u256(self)
    }
}

impl StorableScalar for i64 {
    fn to_word(self) -> u256 {
        __i64_as_u256(self)
    }
}

impl StorableScalar for i128 {
    fn to_word(self) -> u256 {
        __i128_as_u256(self)
    }
}

impl StorableScalar for i256 {
    fn to_word(self) -> u256 {
        __i256_as_u256(self)
    }
}

impl StorableScalar for isize {
    fn to_word(self) -> u256 {
        __isize_as_u256(self)
    }
}

/// Generic field reader for byte-addressable structs.
pub fn get_field<P: Ptr, F: LoadableScalar>(ptr: u256, offset: u256) -> F {
    let target = ptr + offset
    F::from_word(word: P::load(addr:target))
}

/// Writes a scalar field into the given address with the provided offset.
pub fn store_field<P: Ptr, T: StorableScalar>(ptr: u256, offset: u256, value: T) {
    let target = ptr + offset
    P::store(addr: target, value: value.to_word())
}
