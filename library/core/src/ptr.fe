use ingot::intrinsic::{mload, mstore, sload, sstore}

/// Core pointer helpers that read/write struct fields via raw EVM memory/storage.

use ingot::intrinsic::{mload, mstore, sload, sstore}

// Masks used to truncate a 256-bit word down to the requested primitive width.
const U8_MASK: u256 = 0xff
const U16_MASK: u256 = 0xffff
const U32_MASK: u256 = 0xffffffff
const U64_MASK: u256 = 0xffffffffffffffff
const U128_MASK: u256 = 0xffffffffffffffffffffffffffffffff
const U256_MASK: u256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

// Sign bits used when performing two's-complement sign extension per width.
const I8_SIGN_BIT: u256 = 0x80
const I16_SIGN_BIT: u256 = 0x8000
const I32_SIGN_BIT: u256 = 0x80000000
const I64_SIGN_BIT: u256 = 0x8000000000000000
const I128_SIGN_BIT: u256 = 0x80000000000000000000000000000000
const I256_SIGN_BIT: u256 = 0x8000000000000000000000000000000000000000000000000000000000000000

/// Tracks where a value lives so loaders can choose the right builtin.
pub enum AddressSpace {
    Memory,
    Storage,
}

/// Every scalar that can be reconstructed from a raw 256-bit slot implements this.
pub trait LoadableScalar {
    fn from_word(word: u256) -> Self
}

impl LoadableScalar for u8 {
    fn from_word(word: u256) -> Self {
        (word & U8_MASK) as u8
    }
}

impl LoadableScalar for u16 {
    fn from_word(word: u256) -> Self {
        (word & U16_MASK) as u16
    }
}

impl LoadableScalar for u32 {
    fn from_word(word: u256) -> Self {
        (word & U32_MASK) as u32
    }
}

impl LoadableScalar for u64 {
    fn from_word(word: u256) -> Self {
        (word & U64_MASK) as u64
    }
}

impl LoadableScalar for u128 {
    fn from_word(word: u256) -> Self {
        (word & U128_MASK) as u128
    }
}

impl LoadableScalar for u256 {
    fn from_word(word: u256) -> Self {
        word
    }
}

impl LoadableScalar for bool {
    fn from_word(word: u256) -> Self {
        word != 0
    }
}

impl LoadableScalar for i8 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U8_MASK, I8_SIGN_BIT) as i8
    }
}

impl LoadableScalar for i16 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U16_MASK, I16_SIGN_BIT) as i16
    }
}

impl LoadableScalar for i32 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U32_MASK, I32_SIGN_BIT) as i32
    }
}

impl LoadableScalar for i64 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U64_MASK, I64_SIGN_BIT) as i64
    }
}

impl LoadableScalar for i128 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U128_MASK, I128_SIGN_BIT) as i128
    }
}

impl LoadableScalar for i256 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U256_MASK, I256_SIGN_BIT) as i256
    }
}

/// Performs two's-complement sign extension within the provided mask/sign bit.
fn sign_extend(word: u256, mask: u256, sign_bit: u256) -> u256 {
    let value = word & mask
    if value & sign_bit != 0 {
        value | (!mask)
    } else {
        value
    }
}

/// Opposite of `LoadableScalar`: types that can be written back to storage/memory.
pub trait StorableScalar {
    fn to_word(self) -> u256
}

impl StorableScalar for u8 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for u16 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for u32 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for u64 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for u128 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for u256 {
    fn to_word(self) -> u256 {
        self
    }
}

impl StorableScalar for usize {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for bool {
    fn to_word(self) -> u256 {
        if self { 1 } else { 0 }
    }
}

impl StorableScalar for i8 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for i16 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for i32 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for i64 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for i128 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for i256 {
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl StorableScalar for isize {
    fn to_word(self) -> u256 {
        self as u256
    }
}

/// Generic field reader for byte-addressable structs.
pub fn get_field<T, F: LoadableScalar>(addr: u256, space: AddressSpace, offset: u256) -> F {
    let target = addr + offset
    let word = match space {
        AddressSpace::Memory => mload(target)
        AddressSpace::Storage => sload(slot:target)
        _ => 0
    }
    F::from_word(word)
}

/// Writes a scalar field into the given address/space with the provided offset.
pub fn store_field<T: StorableScalar>(
    addr: u256,
    space: AddressSpace,
    offset: u256,
    value: T,
) {
    let target = addr + offset
    match space {
        AddressSpace::Memory => mstore(target, value.to_word()),
        AddressSpace::Storage => sstore(slot:target, value.to_word()),
        _ => {}
    }
}
