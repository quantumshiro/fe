---
source: crates/fmt/tests/format_snapshots.rs
expression: output
input_file: tests/fixtures/match.fe
---
// Test file for match expression and pattern formatting

fn test_match_basic(x: i32) -> i32 {
    match x {
        0 => 100,
        1 => 200,
        _ => 0,
    }
}

fn test_match_with_bindings(opt: Option<i32>) -> i32 {
    match opt {
        Option::Some(value) => value,
        Option::None => 0,
    }
}

fn test_match_record_patterns(message: Message) -> i32 {
    match message {
        Message::Quit | Message::Move { .. } => 0,
        Message::Write { text } => 1,
        Message::Color { r, g, b } => r + g + b,
    }
}

fn test_match_named_fields(point: Point) -> i32 {
    match point {
        Point { x: 0, y: 0 } => 0,
        Point { x: 0, y } => y,
        Point { x, y: 0 } => x,
        Point { x, y } => x + y,
    }
}

fn test_match_nested_record(data: Data) -> i32 {
    match data {
        Data::Named { name, value } => value,
        Data::Complex { inner: Inner { a, b } } => a + b,
    }
}

fn test_match_or_patterns(x: i32) -> i32 {
    match x {
        0 | 1 | 2 => 1,
        3 | 4 | 5 => 2,
        _ => 3,
    }
}

fn test_match_tuple_patterns(pair: (i32, i32)) -> i32 {
    match pair {
        (0, y) => y,
        (x, 0) => x,
        (x, y) => x + y,
    }
}

fn test_match_rest_pattern(tuple: (i32, i32, i32, i32)) -> i32 {
    match tuple {
        (first, ..) => first,
    }
}

fn test_match_with_blocks(x: i32) -> i32 {
    match x {
        0 => {
            let a = 1
            let b = 2
            a + b
        },
        1 => {
            let result = compute_something()
            result * 2
        },
        _ => 0,
    }
}

fn test_match_path_patterns(color: Color) -> i32 {
    match color {
        Color::Red => 1,
        Color::Green => 2,
        Color::Blue => 3,
        Color::Rgb(r, g, b) => r + g + b,
        Color::Custom { name, value } => value,
    }
}

fn test_match_wildcard_fields(point: Point3D) -> i32 {
    match point {
        Point3D { x, .. } => x,
    }
}

fn test_match_long_arm(event: Event) -> i32 {
    match event {
        Event::MouseClick { x: mouse_x, y: mouse_y } => mouse_x + mouse_y,
        Event::KeyPress { key, modifiers: Modifiers { ctrl, shift, alt } } => 1,
        Event::Resize { width: new_width, height: new_height } => new_width * new_height,
    }
}

fn test_match_very_long_pattern(data: ComplexData) -> i32 {
    match data {
        ComplexData::Variant { first_field, second_field, third_field, fourth_field } => first_field
            + second_field,
    }
}

fn test_match_mixed_patterns(input: (Point, Color)) -> i32 {
    match input {
        (Point { x: 0, y: _ }, Color::Red) => 1,
        (Point { x, y }, Color::Rgb(r, g, b)) => x + y + r + g + b,
        _ => 0,
    }
}

// Stubs for types used above
enum Option<T> {
    Some(T),
    None,
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write { text: i32 },
    Color { r: i32, g: i32, b: i32 },
}

struct Point { x: i32, y: i32 }

struct Inner { a: i32, b: i32 }

enum Data {
    Named { name: i32, value: i32 },
    Complex { inner: Inner },
}

enum Color {
    Red,
    Green,
    Blue,
    Rgb(i32, i32, i32),
    Custom { name: i32, value: i32 },
}

struct Point3D { x: i32, y: i32, z: i32 }

struct Modifiers { ctrl: bool, shift: bool, alt: bool }

enum Event {
    MouseClick { x: i32, y: i32 },
    KeyPress { key: i32, modifiers: Modifiers },
    Resize { width: i32, height: i32 },
}

enum ComplexData {
    Variant {
        first_field: i32,
        second_field: i32,
        third_field: i32,
        fourth_field: i32,
    },
}

fn compute_something() -> i32 {
    42
}
