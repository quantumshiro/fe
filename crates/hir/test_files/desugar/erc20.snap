---
source: crates/hir/tests/desugar.rs
expression: output
input_file: test_files/desugar/erc20.fe
---
use core::prelude::*
use core::storage_map::StorageMap
use core::storage_map::StorageKey

const MINTER: u256 = 1

const BURNER: u256 = 2

mod __CoolCoin {
    use super::*
    use core::effect_ref::StorPtr
    use core::intrinsic::contract_field_slot
    use core::calldataload
    use core::calldatasize
    use core::codecopy
    use core::code_region_len
    use core::code_region_offset
    use core::return_data
    use core::revert
    use core::size_of
    use core::encoded_size
    use std::evm::calldata::CallData
    use std::abi::Sol
    use std::abi::sol::SolDecoder
    use std::abi::sol::SolEncoder

    fn recv_Erc20_Transfer_0_0(args: Erc20::Transfer::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let to = args.0
        let amount = args.1
        return {
            transfer(from: ctx.caller(), to, amount)
            true
        }
    }

    fn recv_Erc20_Approve_0_1(args: Erc20::Approve::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let spender = args.0
        let amount = args.1
        return {
            approve(owner: ctx.caller(), spender, amount)
            true
        }
    }

    fn recv_Erc20_TransferFrom_0_2(args: Erc20::TransferFrom::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let from = args.0
        let to = args.1
        let amount = args.2
        return {
            spend_allowance(owner: from, spender: ctx.caller(), amount)
            transfer(from, to, amount)
            true
        }
    }

    fn recv_Erc20_BalanceOf_0_3(args: Erc20::BalanceOf::Args) -> u256 uses (store: TokenStore) {
        let account = args.0
        return {
            store.balances.get(account)
        }
    }

    fn recv_Erc20_Allowance_0_4(args: Erc20::Allowance::Args) -> u256 uses (store: TokenStore) {
        let owner = args.0
        let spender = args.1
        return {
            store.allowances.get((owner, spender))
        }
    }

    fn recv_Erc20_TotalSupply_0_5(args: Erc20::TotalSupply::Args) -> u256 uses (store: TokenStore) {
        return {
            store.total_supply
        }
    }

    fn recv_Erc20_Name_0_6(args: Erc20::Name::Args) -> String<32> {
        return {
            "CoolCoin"
        }
    }

    fn recv_Erc20_Symbol_0_7(args: Erc20::Symbol::Args) -> String<8> {
        return {
            "COOL"
        }
    }

    fn recv_Erc20_Decimals_0_8(args: Erc20::Decimals::Args) -> u8 {
        return {
            18
        }
    }

    fn recv_Erc20Extended_Mint_1_0(args: Erc20Extended::Mint::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log, auth: AccessControl) {
        let to = args.0
        let amount = args.1
        return {
            auth.require(role: MINTER)
            mint(to, amount)
            true
        }
    }

    fn recv_Erc20Extended_Burn_1_1(args: Erc20Extended::Burn::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let amount = args.0
        return {
            burn(from: ctx.caller(), amount)
            true
        }
    }

    fn recv_Erc20Extended_BurnFrom_1_2(args: Erc20Extended::BurnFrom::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let from = args.0
        let amount = args.1
        return {
            spend_allowance(owner: from, spender: ctx.caller(), amount)
            burn(from, amount)
            true
        }
    }

    fn recv_Erc20Extended_IncreaseAllowance_1_3(args: Erc20Extended::IncreaseAllowance::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let spender = args.0
        let added_value = args.1
        return {
            let owner = ctx.caller()
            let current = store.allowances.get((owner, spender))
            approve(owner, spender, amount: current + added_value)
            true
        }
    }

    fn recv_Erc20Extended_DecreaseAllowance_1_4(args: Erc20Extended::DecreaseAllowance::Args) -> bool uses (ctx: Ctx, mut store: TokenStore, mut log: Log) {
        let spender = args.0
        let subtracted_value = args.1
        return {
            let owner = ctx.caller()
            let current = store.allowances.get((owner, spender))
            assert(current >= subtracted_value)
            approve(owner, spender, amount: current - subtracted_value)
            true
        }
    }

    #[contract_init(CoolCoin)]
    fn init() uses (mut ctx: Ctx, mut log: Log) {
        let __len = code_region_len(runtime)
        let __offset = code_region_offset(runtime)
        codecopy(dest: 0, __offset, __len)
        return_data(0, __len)
    }

    #[contract_runtime(CoolCoin)]
    fn runtime() uses (mut ctx: Ctx, mut log: Log) {
        let mut store = StorPtr<TokenStore>::at_offset(contract_field_slot(0))
        let mut auth = StorPtr<AccessControl>::at_offset(contract_field_slot(1))
        let __calldata = CallData {  }
        if calldatasize() < size_of<Sol::Selector>() {
            revert(0, 0)
        }
        let __selector = Sol::selector_from_prefix(calldataload(0))
        if __selector == Erc20::Transfer::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::Transfer::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::Transfer::Args = Erc20::Transfer::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20_Transfer_0_0(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::Approve::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::Approve::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::Approve::Args = Erc20::Approve::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20_Approve_0_1(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::TransferFrom::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::TransferFrom::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::TransferFrom::Args = Erc20::TransferFrom::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20_TransferFrom_0_2(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::BalanceOf::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::BalanceOf::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::BalanceOf::Args = Erc20::BalanceOf::Args::decode(__d)
            let __result = with (store) { recv_Erc20_BalanceOf_0_3(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::Allowance::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::Allowance::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::Allowance::Args = Erc20::Allowance::Args::decode(__d)
            let __result = with (store) { recv_Erc20_Allowance_0_4(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::TotalSupply::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::TotalSupply::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::TotalSupply::Args = Erc20::TotalSupply::Args::decode(__d)
            let __result = with (store) { recv_Erc20_TotalSupply_0_5(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::Name::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::Name::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::Name::Args = Erc20::Name::Args::decode(__d)
            let __result = recv_Erc20_Name_0_6(__args)
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::Symbol::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::Symbol::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::Symbol::Args = Erc20::Symbol::Args::decode(__d)
            let __result = recv_Erc20_Symbol_0_7(__args)
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20::Decimals::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20::Decimals::Args>() {
                revert(0, 0)
            }
            let __args: Erc20::Decimals::Args = Erc20::Decimals::Args::decode(__d)
            let __result = recv_Erc20_Decimals_0_8(__args)
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20Extended::Mint::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20Extended::Mint::Args>() {
                revert(0, 0)
            }
            let __args: Erc20Extended::Mint::Args = Erc20Extended::Mint::Args::decode(__d)
            let __result = with (ctx, store, log, auth) { recv_Erc20Extended_Mint_1_0(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20Extended::Burn::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20Extended::Burn::Args>() {
                revert(0, 0)
            }
            let __args: Erc20Extended::Burn::Args = Erc20Extended::Burn::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20Extended_Burn_1_1(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20Extended::BurnFrom::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20Extended::BurnFrom::Args>() {
                revert(0, 0)
            }
            let __args: Erc20Extended::BurnFrom::Args = Erc20Extended::BurnFrom::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20Extended_BurnFrom_1_2(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20Extended::IncreaseAllowance::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20Extended::IncreaseAllowance::Args>() {
                revert(0, 0)
            }
            let __args: Erc20Extended::IncreaseAllowance::Args = Erc20Extended::IncreaseAllowance::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20Extended_IncreaseAllowance_1_3(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else if __selector == Erc20Extended::DecreaseAllowance::SELECTOR {
            let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
            if calldatasize() < size_of<Sol::Selector>() + encoded_size<Erc20Extended::DecreaseAllowance::Args>() {
                revert(0, 0)
            }
            let __args: Erc20Extended::DecreaseAllowance::Args = Erc20Extended::DecreaseAllowance::Args::decode(__d)
            let __result = with (ctx, store, log) { recv_Erc20Extended_DecreaseAllowance_1_4(__args) }
            let mut __enc = SolEncoder::new()
            __enc.reserve_head(32)
            __result.encode(__enc)
            let __out = __enc.finish()
            return_data(__out.0, __out.1)
        } else { revert(0, 0) }
    }
}

fn transfer(from: Address, to: Address, amount: u256) uses (mut store: TokenStore, mut log: Log) {
    assert(from != Address::zero())
    assert(to != Address::zero())
    let from_balance = store.balances.get(from)
    assert(from_balance >= amount)
    store.balances.set(from, from_balance - amount)
    store.balances.set(to, store.balances.get(to) + amount)
    log.emit(TransferEvent { from, to, value: amount })
}

fn mint(to: Address, amount: u256) uses (mut store: TokenStore, mut log: Log) {
    assert(to != Address::zero())
    store.total_supply += amount
    store.balances.set(to, store.balances.get(to) + amount)
    log.emit(TransferEvent { from: Address::zero(), to, value: amount })
}

fn burn(from: Address, amount: u256) uses (mut store: TokenStore, mut log: Log) {
    assert(from != Address::zero())
    let from_balance = store.balances.get(from)
    assert(from_balance >= amount)
    store.balances.set(from, from_balance - amount)
    store.total_supply -= amount
    log.emit(TransferEvent { from, to: Address::zero(), value: amount })
}

fn approve(owner: Address, spender: Address, amount: u256) uses (mut store: TokenStore, mut log: Log) {
    assert(owner != Address::zero())
    assert(spender != Address::zero())
    store.allowances.set((owner, spender), amount)
    log.emit(ApprovalEvent { owner, spender, value: amount })
}

fn spend_allowance(owner: Address, spender: Address, amount: u256) uses (mut store: TokenStore) {
    let current = store.allowances.get((owner, spender))
    assert(current >= amount)
    store.allowances.set((owner, spender), current - amount)
}

struct TokenStore {
    total_supply: u256,
    balances: StorageMap<Address, u256>,
    allowances: StorageMap<(Address, Address), u256>,
}

pub struct AccessControl {
    roles: StorageMap<(u256, Address), bool>,
}

impl AccessControl {
    pub fn has_role(self, role: u256, account: Address) -> bool {
        self.roles.get((role, account))
    }

    pub fn require(self, role: u256) uses (ctx: Ctx) {
        assert(self.roles.get((role, ctx.caller())) == true)
    }

    pub fn grant(mut self, role: u256, to: Address) {
        self.roles.set((role, to), true)
    }

    pub fn revoke(mut self, role: u256, from: Address) {
        self.roles.set((role, from), false)
    }

}

mod Erc20 {
    use core::prelude::*
    use super::*

    pub struct Name {}

    impl core::message::MsgVariant<std::abi::Sol> for Name {
        type Args = ()
        type Return = String<32>
        const SELECTOR: u32 = 117300739
    }

    impl Name {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }

    pub struct Symbol {}

    impl core::message::MsgVariant<std::abi::Sol> for Symbol {
        type Args = ()
        type Return = String<8>
        const SELECTOR: u32 = 2514000705
    }

    impl Symbol {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }

    pub struct Decimals {}

    impl core::message::MsgVariant<std::abi::Sol> for Decimals {
        type Args = ()
        type Return = u8
        const SELECTOR: u32 = 826074471
    }

    impl Decimals {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }

    pub struct TotalSupply {}

    impl core::message::MsgVariant<std::abi::Sol> for TotalSupply {
        type Args = ()
        type Return = u256
        const SELECTOR: u32 = 404098525
    }

    impl TotalSupply {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }

    pub struct BalanceOf {
        pub account: Address,
    }

    impl core::message::MsgVariant<std::abi::Sol> for BalanceOf {
        type Args = (Address)
        type Return = u256
        const SELECTOR: u32 = 1889567281
    }

    impl BalanceOf {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let account = Address::decode(d)
            return Self { account: account }
        }
    
    }

    pub struct Allowance {
        pub owner: Address,
        pub spender: Address,
    }

    impl core::message::MsgVariant<std::abi::Sol> for Allowance {
        type Args = (Address, Address)
        type Return = u256
        const SELECTOR: u32 = 3714247998
    }

    impl Allowance {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let owner = Address::decode(d)
            let spender = Address::decode(d)
            return Self { owner: owner, spender: spender }
        }
    
    }

    pub struct Transfer {
        pub to: Address,
        pub amount: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for Transfer {
        type Args = (Address, u256)
        type Return = bool
        const SELECTOR: u32 = 2835717307
    }

    impl Transfer {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let to = Address::decode(d)
            let amount = u256::decode(d)
            return Self { to: to, amount: amount }
        }
    
    }

    pub struct Approve {
        pub spender: Address,
        pub amount: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for Approve {
        type Args = (Address, u256)
        type Return = bool
        const SELECTOR: u32 = 157198259
    }

    impl Approve {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let spender = Address::decode(d)
            let amount = u256::decode(d)
            return Self { spender: spender, amount: amount }
        }
    
    }

    pub struct TransferFrom {
        pub from: Address,
        pub to: Address,
        pub amount: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for TransferFrom {
        type Args = (Address, Address, u256)
        type Return = bool
        const SELECTOR: u32 = 599290589
    }

    impl TransferFrom {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let from = Address::decode(d)
            let to = Address::decode(d)
            let amount = u256::decode(d)
            return Self { from: from, to: to, amount: amount }
        }
    
    }
}

mod Erc20Extended {
    use core::prelude::*
    use super::*

    pub struct Mint {
        pub to: Address,
        pub amount: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for Mint {
        type Args = (Address, u256)
        type Return = bool
        const SELECTOR: u32 = 1086394137
    }

    impl Mint {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let to = Address::decode(d)
            let amount = u256::decode(d)
            return Self { to: to, amount: amount }
        }
    
    }

    pub struct Burn {
        pub amount: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for Burn {
        type Args = (u256)
        type Return = bool
        const SELECTOR: u32 = 1117154408
    }

    impl Burn {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let amount = u256::decode(d)
            return Self { amount: amount }
        }
    
    }

    pub struct BurnFrom {
        pub from: Address,
        pub amount: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for BurnFrom {
        type Args = (Address, u256)
        type Return = bool
        const SELECTOR: u32 = 2043438992
    }

    impl BurnFrom {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let from = Address::decode(d)
            let amount = u256::decode(d)
            return Self { from: from, amount: amount }
        }
    
    }

    pub struct IncreaseAllowance {
        pub spender: Address,
        pub added_value: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for IncreaseAllowance {
        type Args = (Address, u256)
        type Return = bool
        const SELECTOR: u32 = 961581905
    }

    impl IncreaseAllowance {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let spender = Address::decode(d)
            let added_value = u256::decode(d)
            return Self { spender: spender, added_value: added_value }
        }
    
    }

    pub struct DecreaseAllowance {
        pub spender: Address,
        pub subtracted_value: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for DecreaseAllowance {
        type Args = (Address, u256)
        type Return = bool
        const SELECTOR: u32 = 2757214935
    }

    impl DecreaseAllowance {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let spender = Address::decode(d)
            let subtracted_value = u256::decode(d)
            return Self { spender: spender, subtracted_value: subtracted_value }
        }
    
    }
}

struct TransferEvent {
    from: Address,
    to: Address,
    value: u256,
}

struct ApprovalEvent {
    owner: Address,
    spender: Address,
    value: u256,
}

fn assert(_ b: bool) {
    if !b {
        core::intrinsics::revert(0, 0)
    }
}

use core::abi::Abi
use core::abi::AbiDecoder
use core::abi::Decode

pub struct Address {
    inner: u256,
}

impl Address {
    pub fn zero() -> Self {
        Address { inner: 0 }
    }

}

impl<A: Abi> Decode<A> for Address {

    fn decode<D: AbiDecoder<A>>(mut _ d: D) -> Self {
        Address { inner: d.read_word() }
    }
}

impl core::ops::Eq for Address {

    fn eq(self, _ other: Address) -> bool {
        self.inner == other.inner
    }
}

impl StorageKey for Address {

    fn write_key(ptr: u256, self) -> u256 {
        core::intrinsic::mstore(ptr, self.inner)
        32
    }
}

pub struct Ctx {}

impl Ctx {
    pub fn caller(self) -> Address {
        todo()
    }

}

pub struct Log {}

impl Log {
    pub fn emit<T>(self, _ event: T) {
        todo()
    }

}
