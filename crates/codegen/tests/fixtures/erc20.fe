use core::{
    StorageMap,
    calldataload,
    code_region_len,
    code_region_offset,
    codecopy,
    keccak,
    mstore,
    return_data,
    revert,
    caller,
}

// Helpers ---------------------------------------------------------------

fn abi_encode_u256(value: u256) {
    mstore(0, value)
    return_data(0, 32)
}

fn abi_encode_string(word: u256, len: u256) {
    // ABI encoding for a single dynamic string literal
    mstore(0, 32)   // offset to data
    mstore(32, len) // string length
    mstore(64, word)
    return_data(0, 96)
}

// FIXME: We don't have tuple support yet, so we manually compute the allowance key
fn allowance_key(owner: u256, spender: u256) -> u256 {
    mstore(0, owner)
    mstore(32, spender)
    keccak(0, 64)
}

// ERC20 storage ---------------------------------------------------------

struct Erc20 {
    balances: StorageMap<u256, u256>,
    allowances: StorageMap<u256, u256>,
    supply: u256,
    owner: u256,
}

impl Erc20 {

    fn balance_of(self, addr: u256) -> u256 {
        self.balances.get(key: addr)
    }

    fn allowance(self, owner: u256, spender: u256) -> u256 {
        self.allowances.get(key: allowance_key(owner, spender))
    }

    fn approve(mut self, owner: u256, spender: u256, value: u256) {
        self.allowances.set(key: allowance_key(owner, spender), value: value)
    }

    fn total_supply(self) -> u256 {
        self.supply
    }

    fn set_owner_once(mut self, owner: u256) {
        if self.owner != 0 {
            revert(0, 0)
        }
        self.owner = owner
    }

    fn transfer(mut self, from: u256, to: u256, amount: u256) {
        let from_bal = self.balance_of(addr: from)
        if from_bal < amount {
            revert(0, 0)
        }
        let to_bal = self.balance_of(addr: to)
        self.balances.set(key: from, value: from_bal - amount)
        self.balances.set(key: to, value: to_bal + amount)
    }

    fn transfer_from(mut self, owner: u256, to: u256, amount: u256) {
        let spender = caller()
        let allowed = self.allowance(owner: owner, spender: spender)
        if allowed < amount {
            revert(0, 0)
        }
        self.transfer(from: owner, to: to, amount: amount)
        self.allowances.set(key: allowance_key(owner, spender), value: allowed - amount)
    }

    fn mint(mut self, to: u256, amount: u256) {
        if caller() != self.owner {
            revert(0, 0)
        }
        let bal = self.balance_of(addr: to)
        self.balances.set(key: to, value: bal + amount)
        self.supply = self.supply + amount
    }
}

// Entry points ----------------------------------------------------------

#[contract_init(Erc20Contract)]
fn init()
{
    let mut erc20: Erc20 = core::effect_ref::StorPtr<Erc20>::at_offset(0)
    erc20.set_owner_once(owner: caller())
    let len = code_region_len(runtime)
    let offset = code_region_offset(runtime)
    codecopy(dest: 0, offset, len)
    return_data(0, len)
}

#[contract_runtime(Erc20Contract)]
fn runtime()
{
    let mut erc20: Erc20 = core::effect_ref::StorPtr<Erc20>::at_offset(0)
    let selector = calldataload(0) >> 224
    match selector {
        0x70a08231 => { // balanceOf(address)
            let owner = calldataload(4)
            abi_encode_u256(value: erc20.balance_of(addr: owner))
        }
        0xdd62ed3e => { // allowance(address,address)
            let owner = calldataload(4)
            let spender = calldataload(36)
            abi_encode_u256(value: erc20.allowance(owner: owner, spender: spender))
        }
        0x06fdde03 => { // name()
            abi_encode_string(
                word: 0x4665546f6b656e00000000000000000000000000000000000000000000000000,
                len: 7,
            )
        }
        0x95d89b41 => { // symbol()
            abi_encode_string(
                word: 0x4645540000000000000000000000000000000000000000000000000000000000,
                len: 3,
            )
        }
        0x313ce567 => { // decimals()
            abi_encode_u256(value: 18)
        }
        0xa9059cbb => { // transfer(address,uint256)
            let to = calldataload(4)
            let amount = calldataload(36)
            erc20.transfer(from: caller(), to: to, amount: amount)
            abi_encode_u256(value: 1)
        }
        0x095ea7b3 => { // approve(address,uint256)
            let spender = calldataload(4)
            let amount = calldataload(36)
            erc20.approve(owner: caller(), spender: spender, value: amount)
            abi_encode_u256(value: 1)
        }
        0x23b872dd => { // transferFrom(address,address,uint256)
            let from = calldataload(4)
            let to = calldataload(36)
            let amount = calldataload(68)
            erc20.transfer_from(owner: from, to: to, amount: amount)
            abi_encode_u256(value: 1)
        }
        0x40c10f19 => { // mint(address,uint256)
            let to = calldataload(4)
            let amount = calldataload(36)
            erc20.mint(to: to, amount: amount)
            abi_encode_u256(value: 1)
        }
        _ => revert(0, 0)
    }
}
