use core::{
    calldatacopy, calldataload, code_region_len, code_region_offset, codecopy, create2, mload,
    mstore, return_data,
}

#[contract_init(Foo)]
fn init() {
    { // create child contract
        let len = code_region_len(child_init)
        let offset = code_region_offset(child_init)
        let dest = allocate(bytes: len)
        codecopy(dest, offset, len)
        create2(value: 0, offset, len: len, salt: 0x1234)
    }

    let len = code_region_len(runtime)
    let offset = code_region_offset(runtime)
    let dest = allocate(bytes: len)
    codecopy(dest, offset, len)
    return_data(dest, len)
}

#[contract_runtime(Foo)]
fn runtime() {
    match read_selector() {
        0x12345678 => { transfer() }
        0x23456789 => { balance() }
        _ => {}
    }
    return_data(0,0)
}

#[contract_init(Child)]
fn child_init() {
    let len = code_region_len(child_runtime)
    let offset = code_region_offset(child_runtime)
    codecopy(dest: 0, offset, len)
    return_data(0, len)
}

#[contract_runtime(Child)]
fn child_runtime() {
    calldatacopy(dest: 0, offset: 0, len: 4)
    return_data(0, 4)
}

fn allocate(bytes: u256) -> u256 {
    let mut ptr = mload(0x40)
    if ptr == 0 {
        ptr = 0x60
    }
    mstore(0x40, ptr + bytes)
    ptr
}

fn balance() {
    return_data(0, 0)
}

fn transfer() {
    return_data(0, 0)
}

pub fn read_selector() -> u256 {
    let word = calldataload(0)
    // Shift right by 224 bits to keep only the first four bytes.
    word >> 224
}
