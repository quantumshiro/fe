use core::{calldataload, code_region_len, code_region_offset, codecopy, mstore, return_data}

struct Inner {
    value: u256,
}

struct Outer {
    inner: Inner,
}

struct MemOuter {
    inner: Inner,
}

fn abi_encode(value: u256) {
    mstore(0, value)
    return_data(0, 32)
}

fn read_inner() -> u256
  uses (outer: Outer)
{
    outer.inner.value
}

fn write_inner(value: u256)
  uses (mut outer: Outer)
{
    outer.inner.value = value
}

fn mem_read(value: u256) -> u256 {
    let mut tmp = MemOuter { inner: Inner { value: 0 } }
    tmp.inner.value = value
    tmp.inner.value
}

#[contract_init(NestedStruct)]
fn init() {
    let len = code_region_len(runtime)
    let offset = code_region_offset(runtime)
    codecopy(dest: 0, offset, len)
    return_data(0, len)
}

#[contract_runtime(NestedStruct)]
fn runtime() {
    let mut outer = core::effect_ref::StorPtr<Outer>::at_offset(0)
    with (outer) {
        let selector = calldataload(0) >> 224
        match selector {
            0xb849fac8 => { // write_inner(uint256)
                let value = calldataload(4)
                write_inner(value)
                abi_encode(value: value)
            }
            0xd164e48d => { // read_inner()
                abi_encode(value: read_inner())
            }
            0x806f30cd => { // mem_read(uint256)
                let value = calldataload(4)
                abi_encode(value: mem_read(value))
            }
            _ => return_data(0, 0)
        }
    }
}
